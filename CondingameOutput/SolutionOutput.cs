// * File generated by SourceCombiner.exe using 6 source files.
// * Created On: 13/11/2020 09:26:32
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
//*** SourceCombiner -> original file ActionType.cs ***
namespace CodinGameOutput
{
    public class ActionType
    {
        public const string BREW = "BREW";
        public const string CAST = "CAST";
        public const string OPPONENT_CAST = "OPPONENT_CAST";
        public const string LEARN = "LEARN";
    }
}
//*** SourceCombiner -> original file Game.cs ***
namespace CodinGameOutput
{
    public class Game
    {
        public Witch[] Witches { get; set; }
        public List<Recipe> Recipes { get; set; }
        public Witch Me { get; }
        public Witch Opponent { get; }
        public Game()
        {
            Me = new Witch();
            Opponent = new Witch();
            Witches = new Witch[] { Me, Opponent};
        }
        public void PrintGameState()
        {
            Console.Error.WriteLine($"{Recipes.Count} recipes at start of round:");
            foreach (var recipe in Recipes)
            {
                Console.Error.WriteLine(recipe.ToString());
            }
            Console.Error.WriteLine("Witches at start of round:");
            Console.Error.WriteLine($"Me: {Me.ToString()}");
            Console.Error.WriteLine($"Opponent: {Opponent.ToString()}");
        }
        public string DecideAction()
        {
            var brewable = Recipes.FirstOrDefault(r => r.Type == ActionType.BREW && Me.CanCookRecipe(r));
            if (brewable != null)
            {
                return $"BREW {brewable.Id}";
            }
            var castableSpells = Recipes.Where(r => r.IsCastable && r.Type == ActionType.CAST);
            // if there are no castable spells, REST
            if (!castableSpells.Any())
            {
                return "REST";
            }
            // if there are any brews, take the first cookable
            if (Recipes.Any(r => r.Type == ActionType.BREW && Me.CanCookRecipe(r)))
            {
            }
            // if i can't cast a spell because I don't have enough resources or have too many to CAST, WAIT
            var cookable = castableSpells.Where(s => Me.CanCookRecipe(s));
            if (!cookable.Any())
            {
                return "REST";
            }
            // else see if I can brew, else cast
            var winningRecipe = cookable.FirstOrDefault(r => r.Type == ActionType.BREW)
                                ?? cookable.FirstOrDefault(r => r.Type == ActionType.CAST);
            foreach (var item in castableSpells)
                Console.Error.WriteLine(item.ToString());
            return $"{winningRecipe.Type} {winningRecipe.Id}";
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
namespace CodinGameOutput
{
    class Player
    {
        static void Main(string[] args)
        {
            string[] inputs;
            var game = new Game();
            while (true)
            {
                game.Recipes = new List<Recipe>();
                var actionCount = int.Parse(Console.ReadLine()); // the number of spells and recipes in play
                for (int i = 0; i < actionCount; i++)
                {
                    inputs = Console.ReadLine().Split(' ');
                    var actionId = int.Parse(inputs[0]); // the unique ID of this spell or recipe
                    var actionType = inputs[1]; // use this variable from league 2 onwards
                    var delta0 = int.Parse(inputs[2]); // tier-0 ingredient change
                    var delta1 = int.Parse(inputs[3]); // tier-1 ingredient change
                    var delta2 = int.Parse(inputs[4]); // tier-2 ingredient change
                    var delta3 = int.Parse(inputs[5]); // tier-3 ingredient change
                    var price = int.Parse(inputs[6]); // the price in rupees if this is a potion
                    var castable = inputs[9] != "0"; // in the first league: always 0; later: 1 if this is a castable player spell
                    if (castable && actionType == "BREW")
                    {
                        Console.Error.WriteLine($"CASTABLE BREW!");
                    }
                    var recipe = new Recipe
                    {
                        Id = actionId,
                        Type = actionType,
                        Ingredients = new int[] { delta0, delta1, delta2, delta3 },
                        Price = price,
                        IsCastable = castable
                    };
                    game.Recipes.Add(recipe);
                    int tomeIndex = int.Parse(inputs[7]); // in the first two leagues: always 0; later: the index in the tome if this is a tome spell, equal to the read-ahead tax
                    int taxCount = int.Parse(inputs[8]); // in the first two leagues: always 0; later: the amount of taxed tier-0 ingredients you gain from learning this spell
                    bool repeatable = inputs[10] != "0"; // for the first two leagues: always 0; later: 1 if this is a repeatable player spell
                }
                for (int i = 0; i < 2; i++)
                {
                    var inventory = new List<int>();
                    inputs = Console.ReadLine().Split(' ');
                    var inv0 = int.Parse(inputs[0]);
                    inventory.Add(inv0);
                    var inv1 = int.Parse(inputs[1]);
                    inventory.Add(inv1);
                    var inv2 = int.Parse(inputs[2]);
                    inventory.Add(inv2);
                    var inv3 = int.Parse(inputs[3]);
                    inventory.Add(inv3);
                    game.Witches[i].Inventory = inventory;
                    var score = int.Parse(inputs[4]);
                    game.Witches[i].Score = score;
                }
                game.PrintGameState();
                var output = game.DecideAction();
                // in the first league: BREW <id> | WAIT; later: BREW <id> | CAST <id> [<times>] | LEARN <id> | REST | WAIT
                Console.WriteLine($"{output}");
            }
        }
    }
}
//*** SourceCombiner -> original file Recipe.cs ***
namespace CodinGameOutput
{
    public class Recipe
    {
        public int Id { get; set; }
        public string Type { get; set; }
        public int[] Ingredients { get; set; }
        public int Price { get; set; }
        public bool IsCastable { get; set; }
        public override string ToString()
        {
            var ingredients = string.Empty;
            foreach (var ingredient in Ingredients)
            {
                ingredients += ingredient + " ";
            }
            return $"Id: {Id}, Type : {Type}, ingredients: {ingredients}, isCastable: {IsCastable}";
        }
    }
}
//*** SourceCombiner -> original file Witch.cs ***
namespace CodinGameOutput
{
    public class Witch
    {
        public List<int> Inventory { get; set; }
        public int Score { get; set; }
        public Witch()
        {
            Inventory = new List<int>();
        }
        public bool CanCookRecipe(Recipe recipe)
        {
            var ingredients = recipe.Ingredients;
            Console.Error.WriteLine(recipe.ToString());
            var sum0 = ingredients[0] + Inventory[0];
            var sum1 = ingredients[1] + Inventory[1];
            var sum2 = ingredients[2] + Inventory[2];
            var sum3 = ingredients[3] + Inventory[3];
            if (recipe.Type == ActionType.CAST)
            {
                var sum = sum0 + sum1 + sum2 + sum3;
                Console.Error.WriteLine($"Cast is cookable?: {sum <= 10}");
                return sum <= 10;
            };
            if (recipe.Type == ActionType.BREW)
            {
                return sum0 >= 0
                    && sum1 >= 0
                    && sum2 >= 0
                    && sum3 >= 0;
            }
            else
            {
                return false;
            }
        }
        public override string ToString()
        {
            var inventory = string.Empty;
            foreach (var ingredient in Inventory)
            {
                inventory += ingredient + " ";
            }
            return $"Score: {Score}, Inventory: {inventory}.";
        }
    }
}
//*** SourceCombiner -> original file .NETCoreApp,Version=v3.1.AssemblyAttributes.cs ***
// <autogenerated />
