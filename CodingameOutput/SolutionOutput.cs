// * File generated by SourceCombiner.exe using 8 source files.
// * Created On: 30/08/2020 12:21:38
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
//*** SourceCombiner -> original file Game.cs ***
namespace CodinGameOutput
{
    public class Game
    {
        private readonly Graph _skynet;
        public Game(Graph skynet)
        {
            _skynet = skynet;
        }
        public string FindTargetLink()
        {
            var agentPosition = _skynet.Virus.CurrentPosition;
            var gateway = _skynet.Nodes.FirstOrDefault(n => n.IsGateway);
            var queue = new Queue<Node>();
            queue.Enqueue(agentPosition);
            var map = new Dictionary<Node, Node>();
            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                foreach (var neighbour in node.Neighbours)
                {
                    if (map.ContainsKey(neighbour))
                        continue;
                    map.Add(neighbour, node);
                    queue.Enqueue(neighbour);
                }
            }
            var path = new List<Node>();
            var current = gateway;
            while (current != agentPosition)
            {
                path.Add(current);
                current = map[current];
            }
            if (path.Count == 1) // if only one element in path then the agent is adjacent to the gateway
                path.Add(current);
            path.Reverse();
            var result = $"{path[0].Id} {path[1].Id}";
            return result;
        }
    }
}
//*** SourceCombiner -> original file Graph.cs ***
namespace CodinGameOutput
{
    public class Graph
    {
        public List<(int, int)> Links { get; set; }
        public List<Node> Nodes { get; set; }
        public Virus Virus { get; set; }
        public Graph()
        {
            Links = new List<(int, int)>();
            Nodes = new List<Node>();
        }
        public void AddLink(int firstNodeId, int secondNodeId)
        {
            var nodeA = Nodes[firstNodeId];
            var nodeB = Nodes[secondNodeId];
            Links.Add((firstNodeId, secondNodeId));
            if (!nodeA.Neighbours.Contains(nodeB))
                nodeA.Neighbours.Add(nodeB);
            if (!nodeB.Neighbours.Contains(nodeA))
                nodeB.Neighbours.Add(nodeA);
        }
        public void AddNodes(int noOfNodes)
        {
            // Node ID must correspond to the node's index in the Nodes collection
            for (int i = 0; i < noOfNodes; i++)
                Nodes.Add(new Node(i));
        }
        public void BuildGraph(int noOfNodes, List<(int, int)> links, List<int> gatewayIndexes)
        {
            AddNodes(noOfNodes);
            for (int i = 0; i < links.Count; i++)
            {
                var node1 = links[i].Item1;
                var node2 = links[i].Item2;
                AddLink(node1, node2);
            }
            for (int i = 0; i < gatewayIndexes.Count; i++)
            {
                var gatewayIndex = gatewayIndexes[i];
                Nodes[gatewayIndex].IsGateway = true;
            }
            Virus = new Virus();
        }
    }
}
//*** SourceCombiner -> original file Node.cs ***
namespace CodinGameOutput
{
    public class Node
    {
        public int Id { get; set; }
        public List<Node> Neighbours { get; set; }
        public bool IsGateway { get; set; }
        public Node(int id)
        {
            Id = id;
            Neighbours = new List<Node>();
        }
    }
}
//*** SourceCombiner -> original file Program.cs ***
namespace CodinGameOutput
{
    class Program
    {
        static void Main(string[] args)
        {
            string[] inputs;
            inputs = Console.ReadLine().Split(' ');
            var noOfNodes = int.Parse(inputs[0]);
            Console.Error.WriteLine($"No of nodes: {noOfNodes}");
            var noOfLinks = int.Parse(inputs[1]);
            Console.Error.WriteLine($"No of Links: {noOfLinks}");
            var noOfGateways = int.Parse(inputs[2]);
            Console.Error.WriteLine($"No of gateways: {noOfGateways}");
            var links = new List<(int, int)>();
            for (int i = 0; i < noOfLinks; i++)
            {
                var link = Console.ReadLine().Split(' ');
                var node1 = int.Parse(link[0]);
                var node2 = int.Parse(link[1]);
                links.Add((node1, node2));
                Console.Error.WriteLine($"Nodes {node1} and node {node2} are linked");
            }
            var gatewayIndexes = new List<int>();
            for (int i = 0; i < noOfGateways; i++)
            {
                var gatewayIndex = int.Parse(Console.ReadLine());
                gatewayIndexes.Add(gatewayIndex);
                Console.Error.WriteLine($"Gateway index: {gatewayIndex}");
            }
            KillTheVirus(noOfNodes, links, gatewayIndexes);
            static string KillTheVirus(int noOfNodes, List<(int, int)> links, List<int> gatewayIndexes)
            {
                var skynet = new Graph();
                skynet.BuildGraph(noOfNodes, links, gatewayIndexes);
                var game = new Game(skynet);
                while (true)
                {
                    var currentPosition = int.Parse(Console.ReadLine());
                    Console.Error.WriteLine($"Agent's current position is: {currentPosition}");
                    skynet.Virus.CurrentPosition = skynet.Nodes[currentPosition];
                    var nextMove = game.FindTargetLink();
                    Console.WriteLine(nextMove);
                }
            }
        }
    }
}
//*** SourceCombiner -> original file Virus.cs ***
namespace CodinGameOutput
{
    public class Virus
    {
        public Node CurrentPosition { get; set; }
    }
}
//*** SourceCombiner -> original file .NETCoreApp,Version=v2.0.AssemblyAttributes.cs ***
// <autogenerated />
//*** SourceCombiner -> original file .NETCoreApp,Version=v3.1.AssemblyAttributes.cs ***
// <autogenerated />
//*** SourceCombiner -> original file .NETCoreApp,Version=v3.1.AssemblyAttributes.cs ***
// <autogenerated />
